# API Design Guide

This document defines patterns and conventions for building API routes under `app/api/*`.

---

## General Principles

- Use REST-style endpoints grouped by domain:
  - `/api/me`, `/api/auth/*`
  - `/api/athletes/*`
  - `/api/recruiting/*`
  - `/api/coach-tools/*`
  - `/api/ai/*`
  - `/api/stripe/*`
- All responses use JSON.
- All input must be validated on the server (e.g., with Zod).
- Do not trust client-side validation.

---

## Error Handling

Always return structured errors:

```ts
import { NextResponse } from "next/server";

return NextResponse.json(
  { error: "Invalid request" },
  { status: 400 }
);
```

Avoid throwing unhandled exceptions; catch errors, log them on the server, and return a clear error message to clients.

---

## Auth Context

Within API routes, authenticate via Supabase:

```ts
const supabase = createSupabaseServerClient();
const { data: { user } } = await supabase.auth.getUser();

if (!user) {
  return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
}
```

Use `user.id` or `user.email` to look up application-level records (e.g., `users` table).

---

## Request Validation

Use `zod` or similar for request bodies:

```ts
import { z } from "zod";

const BodySchema = z.object({
  scope: z.enum(["org", "athlete"]),
  ownerId: z.string().uuid(),
  planCode: z.string(),
});

const json = await request.json();
const body = BodySchema.parse(json);
```

This ensures runtime safety and clear error messaging.

---

## Stripe Webhook Special Case

The Stripe webhook route must:

- Read the raw request body.
- Validate the signature with `STRIPE_WEBHOOK_SECRET`.
- Use a Supabase service-role client for writing subscription rows.

All other routes should rely on RLS-aware clients, not the service role.

---

Follow these patterns to keep the API consistent and secure.
